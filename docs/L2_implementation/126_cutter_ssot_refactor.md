# #126 Cutterクラス of SSOT完全対応とAdapter排除

## 1. 実装(技術)について

### 1.1 Adapterの完全廃止
`main.ts` の `executeCut` メソッド内に存在していた、`SolidSSOT` からレガシーな配列ベースの構造（`proxyCube` / `structure`）への変換ロジックをすべて削除しました。これにより、以下の二重管理が解消されました。
- `SolidSSOT` (Record形式) と レガシー構造 (Array形式) の同期コスト
- CSG演算用のダミーメッシュ (`proxyMesh`) の生成と管理

### 1.2 CutterクラスのSSOTネイティブ化
`Cutter.ts` を改修し、`SolidSSOT` を直接入力として受け取れるようにしました。
- **`isSolidSSOT` ヘルパーの導入**: 実行時にオブジェクトが `SolidSSOT` かレガシーモックかを判別し、適切なデータアクセスを選択するようにしました。
- **IDベースのデータアクセス**: `Object.values(solid.vertices)` などを利用し、配列インデックスに依存しないロジックへ移行しました。
- **動的ジオメトリ生成**: CSG演算に必要な `BoxGeometry` を、SSOT内の `meta.size` 情報から `Cutter` 内部で動的に生成するように変更しました。これにより、呼び出し側（`main`）が描画用の詳細を知る必要がなくなりました。

### 1.3 周辺モジュールの追従
- **`explanationGenerator.ts`**: `SolidSSOT` (Record形式) をサポートするように `StructureSummary` 型を拡張しました。ラベル取得ロジックにおいて、従来の `Map` 参照と新規の `Record` 参照の両方を試行する堅牢な実装に変更しました。

## 2. 仕様(L1ドキュメント)について

### 2.1 3層アーキテクチャの遵守
L1仕様（`00_overview.md`）で定義された「SSOT Layer を唯一の真実とする」原則を徹底しました。`Cutter` は SSOT のみを参照し、`Derived Layer` である切断結果（`facePolygons`, `intersections` 等）を生成する、純粋な `Resolver` 的な役割へと整理されました。

### 2.2 IDの一貫性
頂点 ID (`V:<n>`) やエッジ ID (`E:<a>-<b>`) をキーとして直接探索を行うことで、構造主導アーキテクチャの要である「IDによる厳密な接続性の担保」がコードレベルで実現されました。

## 3. 数学的観点から

### 3.1 座標計算の精度と安定性
SSOT化により、`GeometryResolver` による精密な座標解決結果が直接計算に供されるようになりました。これにより、以前の Adapter 変換で発生していた可能性のある微小な座標変換誤差が排除されました。

### 3.2 数値的不安定性の顕在化
一方で、精密な座標が入力されたことで、既存のクリッピングロジックにおける `epsilon`（`1e-5`）の閾値判定が、特定の頂点通過ケース（例：`Hexagon` カット）において極めて敏感になることが判明しました。これはリファクタリングそのもののバグではなく、座標主導から構造主導へ移行したことで、従来の「曖昧な座標一致」に頼っていたロジックの限界が可視化されたものです。

## 4. ユーザー体験(ユーザー価値)について

### 4.1 保守性と拡張性の向上
Adapter という「翻訳層」が消えたことで、将来的に複雑な多面体や、動的に変化する立体を扱う際にも、SSOT を変更するだけで切断ロジックが正しく追従できる土台が整いました。

### 4.2 計算の確実性
IDベースでの接続確認（`GeometryValidator` での検証）により、見た目だけではない「数学的に正しい立体」としての品質が保証されるようになりました。