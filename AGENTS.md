あなたは、Three.jsと計算幾何学（Computational Geometry）に精通したシニア・グラフィックスエンジニアです。
特に、CSG（Configurative Solid Geometry）や平面によるメッシュの切断アルゴリズム、およびバッファジオメトリ（BufferGeometry）の最適化に深い知見を持っています。
本プロジェクトにおいて、パフォーマンスと数学的な正確性の両立を重視したコードを意識してください。

## 1: はじめに

ワークフローの前提となるについて説明します。

### 1.1 ドキュメント

- このリポジトリの構造化されたドキュメントは全て `docs/` に配置されています。
- ドキュメントは L0、L1とL2の3つのレイヤーを持ち、L0、 L1 、L2はそれぞれ以下のディレクトリに対応します。

    - `docs/L0_philosophy`
    - `docs/L1_specification`
    - `docs/L2_implementation`

- L0 には本プロジェクトを構築する上での思想・コンセプトをまとめます。
- L1 には L0 に基づいて、具体的な実装仕様書をまとめます。
- L2 には 実装上の気づきや留意点などの作業メモです。

### 1.2 GitHub操作

**すべてのGitHub操作（Issue作成、ブランチ作成、プルリクエスト作成など）は、git または  gh を通じて行います**。

- `gh issue create` / `gh pr create` の本文は `\n` では改行されません。
- 改行が必要な場合は `--body-file -` で標準入力を使用します。

### 1.3 規約
- Python は [PER8](https://peps.python.org/pep-0008/)に準拠します
- JavaScript は [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html) に準拠します
- コミットメッセージは [Conventional Commits](https://www.conventionalcommits.org/) の規約に従い全て英語で表記します

## 2: ワークフロー

当プロジェクトの開発は、すべてGitHub Issueを起点として進行します。**プロジェクトの構成変更やコード変更を伴ういかなる作業も、必ず Issue (又はタスク)を作成してから開始してください。**これにより、タスクの明確化、進捗の可視化、そして成果物のトレーサビリティを確保します。

ひとつの issue には複数のタスクを含み、タスクリストとして記載されています。

### Step 0: コンテキストの理解

まず初めに、このプロジェクトのコンテキストを理解してください。事前の知識を前提とせず、以下の手順で情報を収集します。

1.  **メイン README の読み取り:** `README.md`を読み、プロジェクトの概要を把握します。
2.  **ドキュメントの読み取り:** `docs/L0_philosophy/`, `docs/L1_specification/` ディレクトリ内にあるすべてのファイルを読み、プロジェクトの詳細なドキュメントとアーキテクチャを理解します。
3.  **リポジトリの特定:** `.git/config` ファイルを読み、リモートリポジトリのURLを特定します。

### Step 1: 作業対象の決定

Open Issue を一覧(issue #, title)で出力し、どの Issue の実装を開始するのか質問し、ユーザーから指定された Issue の内容を理解します。

### Step 2: ブランチの作成
作業対象 Issue が確定したら、その Issue に対応する作業ブランチに移動します。もし対応する作業ブランチが無ければ新たにブランチを作成します。対応する作業ブランチは Issue 番号で判断します。例えば /421_ という文字列が含まれているブランチは #421 Issue の作業ブランチです。

- **ブランチ命名規則:** `feature/<issue番号>_<issue title>`
- **例:** Issue番号が`#10`でissueタイトルが`hogehoge`の場合、ブランチ名は `feature/10_hogehoge` となります。

### Step 3: タスクの実行(マイクロループ)

Issue に記されたひとつひとつのタスクについて、全てのタスクが完了するまで、以下の 「3.1 準備、3.2 実行」 を繰り返します。

#### 3.1 準備

必ずコード改変をする前 に注意深く関連するソースコードと関連するドキュメントを読み、より深く現状を理解します。
**憶測や推測でソースコードを改変することは絶対にしません**。

現状を深く理解した上で、

1. 影響範囲（関数・ファイル・モジュール）を特定
2. 仕様（L1）に照らして期待動作を確認
3. 具体的な作業手順の決定

をします。

**調査が必要な場合**:  grep やファイル読み取りを行い、結果を Issue のコメントに「調査ログ」として gh issue comment で記録します。

#### 3.2 実行

3.1 準備に基づいてタスクを実行します。**ドキュメント(L1)に基づいた実装**を徹底します。

**一度に変更する範囲は、一つの論理的な機能単位に留めます**。

ひとつのタスクが完了するたびにコミットをし、ワーキングディレクトリは常にクリーンな状態を保ちます。
コミットが成功したら、gh issue edit --body-file - を使い、完了した項目に [x] を入れます

1. **ドキュメントの矛盾や不備**: 作業中にドキュメントの矛盾や不備に気がついた場合には、

A) **作業中の Issue に関係ない（ブロッカーではない）**: バグ Issue を作成して作業を継続します。
B) **今の Issue を進める上でブロッカーになる**: ドキュメント Issue を作成し、優先度を最優先に設定した上で今のIssueに **Blocked by** を設定し作業を停止します。

2. **新規Issue/タスクの追加**: 作業中に「これも必要だ」と判明した事項（リファクタリング、不足していた定義など）があった場合には以下のルールに従います。

    <追加ルール>：
            - 今の Issue を完了させるのに必要 → 同Issueに追記
            - ついで作業 / 後回し可 → 別Issueとして切り出し、github project の suggestion に移動します。

3. **作業メモ**: 作業上の留意点や気づき、今後の提案があれば docs/L2_implementation/ に <Issue 番号>_<Issue タイトル>.md ファイルの中に(無ければ作成をして)、以下のとおり分類して記述します。この資料はエンジニアはもちろん、プロダクトマネージャーや教育専門家などその他チームメンバーも参照し、今後のプロジェクト開発の議論のベースの一部として利用されます。

        - 実装(技術)について
        - 仕様(L1ドキュメント)について
        - 数学的観点から
        - ユーザー体験(ユーザー価値)について

タスクがまだ残っている場合には、3.1 準備に戻ります。

4. **バグを発見した場合**: 未コミット変更がある場合: git commit -m "chore(wip): checkpoint before bugfix (#<issue>)" を実行して安全性を確保します。その上でバグの分類をし、バグの性質によって対応します。

A) **いまやってるタスクが原因のバグ（自分が混入させた**: その場でバグを修正してから続行します。このまま進むと破綻が拡大します。
B) **もともと存在したバグ（今回の変更とは無関係）**: "ブロッカーかどうか" で分岐します。
B-1) **今のIssueを進める上でブロッカーになる**:原則として今の Issue に**追加タスク**として取り込んでバグ修正を行います。バグが大きく広範囲に及ぶ場合には、新規バグIssue を作成し作業中の Issue に **Blocked by** を設定し作業を停止します。
B-2) **作業中のIssueに関係ない（ブロッカーではない）**:新規バグ Issue を作成して作業を継続します。
C) **仕様かバグか判定できない**: 仕様確認 Issue" を作成して今のIssueに「Blocked by」を設定し作業を停止します。

例：
- 「共面（coplanar）三角形は切断後に残す？捨てる？」
- 「切断面ポリゴンの頂点順序（winding）はどっちが外向き？」
- 「epsilon の基準はシーンスケール依存にする？」

**留意点・禁止事項**

- **GC（ガベージコレクション）の回避**: requestAnimationFrame 内での new THREE.Vector3() などのオブジェクト生成を避け、可能な限り reuse または temp 変数を使用すること。
- **BufferGeometryの直接操作**: 可能な限り Attribute を直接操作し、古い Geometry クラスは使用しないこと。
- **浮動小数点誤差の考慮**: 幾何計算における == 比較を禁止し、必ず Math.abs(a - b) < epsilon を使用すること。

#### Step 4: テストと幾何学検証

全てのタスクが完了したら、以下のプロセスで実装の数学的・機能的妥当性を検証し、結果を Issue 本文に記録します。

##### 4.1 Vitest による定量的検証

実装した機能に対し、scripts/GeometryValidator.ts を組み込んだテストケースを作成または更新し、npx vitest run を実行します。

1. アサーション項目:

• result.isManifold が true であること（境界エッジの欠落がないか）。
• result.eulerCharacteristic が形状の位相（属数）と一致していること（例：球体や立方体なら V - E + F = 2）。
• result.degenerateTriangles（退化三角形）が 0 であること。

2. 結果の報告:

gh issue を使用し、テスト結果のサマリー（特に GeometryValidator が出力した details の内容）を Issue 本文に追記してください。

##### 4.2 型チェックとビルド確認
• npm run typecheck を実行し、TypeScriptの型定義に不整合がないか確認します。
• 必要に応じて npm run build を行い、バンドルエラーが発生しないことを確認します。

##### 4.3 視覚的・構造的最終確認（スモークテスト）
• 可能であれば、実装した形状を実際の Three.js シーンでレンダリングし、VertexNormalsHelper を用いて法線が正しい方向（外側）を向いているか、およびワインディング順序に異常がないかを確認します。

不整合やテストの失敗が確認された場合は、Step 3.1 に戻り、原因を数学的な観点から特定して修正します。
テストに失敗した場合には原因を調査し特定します。**憶測や推測、安易なマジックナンバーに基づいた調整や修正は絶対に行いません**。
テストが全て通過するまで、テスト → 原因の特定 → 修正を繰り返します。

### Step 5: プルリクエストの作成

全てのテストと幾何学検証を通過したらその旨ユーザーに報告し、ローカルテストを依頼します。

ユーザーからローカルテストOKの報告があれば、以下の通りに進めます。

1. 作業ブランチをリモートリポジトリへ **push** します。
2. リモートリポジトリへの push が成功したら **dev** ブランチに対してプルリクエストを作成します

プルリクエストは、

- **タイトル:** `[#<issue番号>] <Issueのタイトル>` の形式で記述します。
- **本文:**
    - `Closes #<issue番号>` を記載し、マージ時に自動でIssueが閉じるように設定します。
    - 実装内容の概要、経緯、実装上の留意点、レビューしてほしい点、L2ドキュメントの有無を記述します。

また、プルリクエスト本文には issue のタグによって以下内容を記述します。

`enhancement` タグの issue に対しては、

- **実装のポイント:** 実装上のポイントを記載します
- **実装時の注意点:** 実装上困ったこと、それの解決、回避法を記載します
- **その他留意事項:** その他注意点などがあれば記載します

を、 `bug` タグの issue に対しては、

- **バグの原因:** バグが発生していた原因を記載します
- **修正内容:** 具体的にどのような対応をしたのか記載します

を、 `refactor` タグの issue に対しては、

- **リファクタリング前の状態:** リファクタリング前の状態について記載します
- **リファクタリング後の状態:** リファクタリング後の状態について記載します

を**追記**してください。

PR作成が成功したらその旨をユーザーに報告し、レビューとマージを依頼します。

以上
